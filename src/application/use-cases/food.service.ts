import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { Category, FoodItem } from '../../domain/entities/food.entity';
import { ICategoryRepository, IFoodRepository } from '../../domain/repositories/food.repository.interface';
import { CreateFoodItemDto, SearchFoodDto, UpdateFoodItemDto } from '../dto/food.dto';

@Injectable()
export class FoodService {
  constructor(
    private readonly foodRepository: IFoodRepository,
    private readonly categoryRepository: ICategoryRepository,
  ) {}

  async createFoodItem(restaurantId: string, createFoodItemDto: CreateFoodItemDto): Promise<FoodItem> {
    // Validate category exists
    const categoryExists = await this.validateCategory(createFoodItemDto.category);
    if (!categoryExists) {
      throw new BadRequestException('Invalid category');
    }

    const newFoodItem = new FoodItem(
      '', // ID will be generated by repository
      createFoodItemDto.name,
      createFoodItemDto.description,
      createFoodItemDto.image,
      createFoodItemDto.price,
      createFoodItemDto.originalPrice || null,
      0, // Initial rating
      0, // Initial reviews
      createFoodItemDto.category,
      restaurantId,
      '', // Restaurant name will be set by repository
      createFoodItemDto.ingredients,
      createFoodItemDto.allergens || [],
      createFoodItemDto.isVegetarian,
      createFoodItemDto.isVegan,
      createFoodItemDto.isSpicy,
      createFoodItemDto.preparationTime,
      createFoodItemDto.calories || null,
      true, // Available by default
      false, // Not featured by default
      false, // Not popular by default
      new Date(),
      new Date(),
    );

    return await this.foodRepository.create(newFoodItem);
  }

  async updateFoodItem(id: string, updateFoodItemDto: UpdateFoodItemDto): Promise<FoodItem> {
    const existingFoodItem = await this.foodRepository.findById(id);
    if (!existingFoodItem) {
      throw new NotFoundException('Food item not found');
    }

    return await this.foodRepository.update(id, updateFoodItemDto);
  }

  async deleteFoodItem(id: string): Promise<void> {
    const existingFoodItem = await this.foodRepository.findById(id);
    if (!existingFoodItem) {
      throw new NotFoundException('Food item not found');
    }

    await this.foodRepository.delete(id);
  }

  async getFoodItemById(id: string): Promise<FoodItem> {
    const foodItem = await this.foodRepository.findById(id);
    if (!foodItem) {
      throw new NotFoundException('Food item not found');
    }
    return foodItem;
  }

  async searchFoodItems(searchDto: SearchFoodDto): Promise<{
    items: FoodItem[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const page = searchDto.page || 1;
    const limit = searchDto.limit || 10;

    let result;

    if (searchDto.query) {
      result = await this.foodRepository.search(searchDto.query, page, limit);
    } else if (searchDto.category) {
      result = await this.foodRepository.findByCategory(searchDto.category, page, limit);
    } else {
      result = await this.foodRepository.findAll(page, limit);
    }

    // Apply additional filters
    let filteredItems = result.items;

    if (searchDto.minPrice !== undefined || searchDto.maxPrice !== undefined) {
      const min = searchDto.minPrice || 0;
      const max = searchDto.maxPrice || Number.MAX_SAFE_INTEGER;
      filteredItems = filteredItems.filter(item => item.price >= min && item.price <= max);
    }

    if (searchDto.isVegetarian !== undefined) {
      filteredItems = filteredItems.filter(item => item.isVegetarian === searchDto.isVegetarian);
    }

    if (searchDto.isVegan !== undefined) {
      filteredItems = filteredItems.filter(item => item.isVegan === searchDto.isVegan);
    }

    const totalFiltered = filteredItems.length;
    const totalPages = Math.ceil(totalFiltered / limit);

    return {
      items: filteredItems,
      total: totalFiltered,
      page,
      totalPages,
    };
  }

  async getFeaturedItems(limit: number = 6): Promise<FoodItem[]> {
    return await this.foodRepository.findFeatured(limit);
  }

  async getPopularItems(limit: number = 6): Promise<FoodItem[]> {
    return await this.foodRepository.findPopular(limit);
  }

  async getFoodItemsByRestaurant(restaurantId: string, page: number = 1, limit: number = 10): Promise<{
    items: FoodItem[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const result = await this.foodRepository.findByRestaurantId(restaurantId, page, limit);
    const totalPages = Math.ceil(result.total / limit);

    return {
      items: result.items,
      total: result.total,
      page,
      totalPages,
    };
  }

  async getAllCategories(): Promise<Category[]> {
    return await this.categoryRepository.findActive();
  }

  private async validateCategory(categoryName: string): Promise<boolean> {
    const categories = await this.categoryRepository.findActive();
    return categories.some(cat => cat.name.toLowerCase() === categoryName.toLowerCase());
  }
}